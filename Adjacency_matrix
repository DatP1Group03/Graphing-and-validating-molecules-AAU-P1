#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define ASCII_ZERO 48

int bond_order(char c);

int get_bond_value(char S[], int index);

int get_atom_count(char S[]);

int* find_adjacency(char S[], int atom_count);

void convert_matrix(int* adj, int atom_count, int adjacency_matrix[atom_count][atom_count]);

void create_adjacency_matrix(char* SMILES, int atom_count, int adjacency_matrix[atom_count][atom_count]);

void create_adjacency_matrix(char* SMILES, int atom_count, int adjacency_matrix[atom_count][atom_count]) {
    int *Adjacency = find_adjacency(SMILES, atom_count);

    convert_matrix(Adjacency, atom_count, adjacency_matrix);

    free(Adjacency);
}

int *find_adjacency(char S[], int atom_count) {
    int length = (int) strlen(S);
    int rings[10] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

    int *ADJ = malloc(sizeof(int) * atom_count * atom_count);

    for (int i = 0; i < atom_count * atom_count; i++) {
        ADJ[i] = 0;
    }

    int current = 0,
            prev = -1;

    for (int i = 0; i < length; i++) {
        if (isalpha(S[i])) {
            if (prev == -1) {
            } else if ( (S[i - 1] == ')' || S[i - 1] == '(') ||
                 ( (S[i-1]=='=' || S[i-1]=='#'||S[i-1]=='-')
                    && (S[i-2] == '(' && S[i-3]==')')|| S[i-2]==')' )) {
                int j;
                if (S[i - 2] == ')') {
                     j = i - 2;
                } else {
                    j = i - 1;
                }
                int k = 0;
                if (S[i-2]=='(' && (S[i-1]=='=' || S[i-1]=='#'||S[i-1]=='-')) {
                    k++;
                }
                do {
                    if (S[j] == ')') {
                        k++;
                    } else if (S[j] == '(') {
                        k--;
                        if (S[j - 1] == ')') {
                            k++;
                            j--;
                        }
                    }
                    j--;
                } while (k != 0);
                int count = 0;
                for (int l = j; l > 0; l--) {
                    if (isalpha(S[l])) {
                        count++;
                    }
                }
                ADJ[current * atom_count + count] = get_bond_value(S, i - 1);
            } else {
                ADJ[current * atom_count + prev] = get_bond_value(S, i - 1);
            }
            prev++;
            current++;
        } else if (isdigit(S[i]) != 0) {
            int number = (int) S[i] - ASCII_ZERO;
            if (rings[number] == -1) {
                rings[number] = prev;
            } else {
                ADJ[rings[number] + prev * atom_count] = 1;
            }
        }
    }
    for (int i = atom_count-1; i>=0;i--) {
        for (int j = i; j>=0;j--) {
            ADJ[i+j*atom_count] = ADJ[i*atom_count+j];
        }
    }
    return ADJ;
}

int bond_order(char c) {
    switch (c) {
        case '-':
            return 1;
        case '=':
            return 2;
        case '#':
            return 3;
        default:
            return 1;
    }
}

int get_bond_value(char S[], int index) {
    if (isalpha(S[index])) {
        return 1;
    }
    return bond_order(S[index]);
}

int get_atom_count(char S[]) {
    int counter = 0;
    for (int i = 0; i < strlen(S); i++) {
        if (isalpha(S[i])) {
            counter++;
        }
    }
    return counter;
}

void print_ADJ(const int *adj, int atom_count) {
    for (int i = 0; i < atom_count; i++) {
        for (int j = 0; j < atom_count; j++) {
            printf("%d ", adj[i * atom_count + j]);
        }
        printf("\n");
    }
}

void convert_matrix(int* adj, int atom_count, int adjacency_matrix[atom_count][atom_count]) {
    for (int i = 0; i<atom_count;i++) {
        for (int j = 0; j<atom_count; j++) {
            adjacency_matrix[j][i] = adj[i*atom_count+j];
        }
    }
}
