//
// Created by jonas on 09-12-2025.
//

#include "Graph_representation.h"



/*
 * draw_molecule()
 * Computes 2D positions for each atom based on the SMILES string and then renders:
 *  - atoms as colored circles (based on node_matrix atom type),
 *  - bonds as lines (single/double/triple based on adjacency_matrix).
 *
 * The layout is generated by scanning the SMILES left-to-right while tracking:
 *  - ring openings/closures (digits),
 *  - whether we are currently inside a ring,
 *  - sidechain branches using a stack (S_list).
 */
void draw_molecule(char *SMILES, int atom_count, int adjacency_matrix[atom_count][atom_count], int ring_count, double node_matrix[atom_count][3], Vector2 origin) {
	printf("%d \n", ring_count);
	int SMILES_length = strlen(SMILES);
	S_list sideChains;
	sideChains.head = NULL;

	int rings[ring_count];
	for (int i = 0; i<ring_count; i++) {
		rings[i]=1;
	}

	ringSize(SMILES,ring_count, rings);
	for (int i = 0; i<ring_count;i++) {
		printf("%d\n",rings[i]);
	}

	int current_atom = 0;
	int atoms_in_current_ring = 0;
	short in_ring = 0;
	int ring_counter = 0;
	int started_rings[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int start_of_sidechain = 0;

	Vector2 positions[atom_count];

	positions[0].x = origin.x;
	positions[0].y = origin.y;

	Vector2 position_increment;
	position_increment.x = RADIUS * 2 + BOND_LENGTH;
	position_increment.y = 0;

	for (int i = 0; i < SMILES_length; i++) {
		if (isalpha(SMILES[i])) {
			if (current_atom == 0) {
			} else if (start_of_sidechain) {
				positions[current_atom] = Vector2Add(positions[start_of_sidechain], position_increment);
				start_of_sidechain = 0;
				if (in_ring) {
					ring_rotation(&position_increment, atoms_in_current_ring);
				}
			} else if (in_ring) {
				positions[current_atom] = Vector2Add(positions[current_atom - 1], position_increment);
				ring_rotation(&position_increment, atoms_in_current_ring);
			} else {
				positions[current_atom] = Vector2Add(positions[current_atom - 1], position_increment);
			}
			current_atom++;
		}
		if (isdigit(SMILES[i])) {
			//printf("digit %d  in_ring=%d  atoms_in_current_ring=%d  ring_counter=%d\n", SMILES[i] - '0', in_ring, atoms_in_current_ring, ring_counter);
			if (started_rings[SMILES[i] - '0']) {
				started_rings[SMILES[i] - '0'] = 0; // ringen lukkes mulig vis  
				in_ring--;
				if (in_ring == 0) {
					ring_rotation(&position_increment, -1 * atoms_in_current_ring);
				}
			} else if (ring_counter != 0) {
				if (ring_counter % 2 != 0) {
					atoms_in_current_ring = -rings[ring_counter];
				} else {
					atoms_in_current_ring = rings[ring_counter];
				}
				started_rings[SMILES[i] - '0'] = 1;
				in_ring++;
				ring_counter++;
			} else {
				atoms_in_current_ring = rings[ring_counter];
				started_rings[SMILES[i] - '0'] = 1;
				in_ring++;
				ring_counter++;
			}
		}
		if (SMILES[i] == '(') {
			add_side_chain(&sideChains, current_atom - 1, position_increment);
			//if (in_ring) {
			////} else {
			if (ring_counter % 2 != 0) {
				rotate_Vector(&position_increment, -PI / 2);
			}
			rotate_Vector(&position_increment, PI / 2);
			// }
			}
		if (SMILES[i] == ')') {
			if (SMILES[i + 1] == '(') {
				add_side_chain(&sideChains, sideChains.head->side_chain_head, sideChains.head->position_increment);
				if (in_ring) {
					rotate_Vector(&position_increment, -2 * PI / 3);
				} else {
					rotate_Vector(&position_increment, PI);
				}
				i++;
				start_of_sidechain = sideChains.head->side_chain_head;
			} else {
				start_of_sidechain = sideChains.head->side_chain_head;
				position_increment = sideChains.head->position_increment;
				remove_side_chain(&sideChains);
			}
		}
	}
	Draw_bonds(atom_count, positions, adjacency_matrix);
	Draw_atoms(atom_count, positions, node_matrix, SMILES);
}

/*
 * ringSize()
 * Estimates the size (number of atoms) of each ring encountered in the SMILES string.
 *
 * The function tracks which ring digits are "open" and counts atoms while the ring is open.
 * It attempts to ignore atoms that are inside parentheses (sidechains), since those atoms
 * should not contribute to the ring length.
 *
 * Output:
 *  - ring[] is filled with computed sizes for each ring (index corresponds to ring_counter order).
 */
void ringSize(char *SMILES, int ring_count, int ring[ring_count]) {
	int visited_rings_numbers[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int visited_rings[ring_count];
	for (int i = 0; i<ring_count;i++) {
		visited_rings[i]=0;
	}
	int count = 0;
	for (int i = 0; i < strlen(SMILES); i++) {
		if (isdigit(SMILES[i])) {
			if (visited_rings_numbers[SMILES[i] - '0']) {
				visited_rings[visited_rings_numbers[SMILES[i] - '0']-1] = 0;
			} else {
				visited_rings_numbers[SMILES[i] - '0'] = count+1;
				visited_rings[count] = 1;
				count++;
			}
		}
		if (isalpha(SMILES[i])) {
			for (int j = 0; j < ring_count; j++) {
				if (visited_rings[j]) {
					ring[j] += 1;
				}
			}
		}
		if (SMILES[i] == '(') {
			while (SMILES[i] != ')') {
				if (isdigit(SMILES[i])) {
					i-=1;
					break;
				}
				i++;
			}
		}
	}
}

/*
 * ring_rotation()
 * Rotates the drawing direction vector by an angle corresponding to the polygon
 * angle step of a ring with size size_of_ring.
 *
 * This is used to place atoms around a ring shape by changing the direction after each atom.
 */
void ring_rotation(Vector2 *vector, int size_of_ring) {
	double radians = 2 * PI / (double) size_of_ring;
	rotate_Vector(vector, radians);
}

/*
 * rotate_Vector()
 * Rotates a 2D vector by the given angle (radians) while preserving its length.
 *
 * Implementation detail:
 *  - Converts the vector to polar coordinates (length + angle),
 *  - Adds the rotation angle,
 *  - Converts back to Cartesian coordinates (x, y).
 */
void rotate_Vector(Vector2 *vector, double radians) {
	double length = sqrt(pow(vector->x, 2) + pow(vector->y, 2));
	double angle = atan(vector->y / vector->x);
	if (vector->x < 0) {
		angle += PI;
	} else if (vector->x > 0 && vector->y < 0) {
		angle += 2 * PI;
	}
	angle += radians;
	vector->x = cos(angle) * length;
	vector->y = sin(angle) * length;
}


/*
 * Draw_atoms()
 * Draws each atom as a circle at its computed position.
 *
 * Atom color is determined by node_matrix[i][0] (atomic number):
 *  - 6 -> carbon (black)
 *  - 8 -> oxygen (red)
 *  - 7 -> nitrogen (blue)
 * Default case:
 *  - draws a black circle and writes the atom symbol as text.
 */
void Draw_atoms(int atom_count, Vector2 positions[atom_count], double node_matrix[atom_count][3], char* SMILES) {
	Color color;
	for (int i = 0; i < atom_count; i++) {
		int node_type = (int)node_matrix[i][0]; 
		switch (node_type) {
			case 6:
				color = BLACK;
				DrawCircle(positions[i].x, positions[i].y,RADIUS, color);
				break;
			case 8:
				color = RED;
				DrawCircle(positions[i].x, positions[i].y,RADIUS, color);
				break;
			case 7:
				color = BLUE;
				DrawCircle(positions[i].x, positions[i].y,RADIUS, color);
				break;
			default:
				color = BLACK;
				DrawCircle(positions[i].x, positions[i].y,RADIUS, color);
				int atom_count2=0;
				int j=0;
				while (atom_count2 != i) {
					j++;
					if (isalpha(SMILES[i])) {
						atom_count2++;
					}
				}
				char atom_name_str[2] = {SMILES[i], '\0'};
				DrawText(atom_name_str,positions[i].x-4, positions[i].y-4,15,WHITE);
				break;
		}
	}
}

/*
 * Draw_bonds()
 * Draws bonds between atoms based on the adjacency matrix:
 *  - 1 -> single bond (one line)
 *  - 2 -> double bond (two parallel lines)
 *  - 3 -> triple bond (three parallel lines)
 *
 * For double/triple bonds, an orthogonal offset vector is used to draw parallel lines.
 */
void Draw_bonds(int atom_count, Vector2 positions[atom_count], int adj[atom_count][atom_count]) {
	for (int i = 0; i < atom_count; i++) {
		for (int j = i + 1; j < atom_count; j++) {
			switch (adj[i][j]) {
				case 1:
					DrawLineEx(positions[i], positions[j], 3,WHITE);
					DrawLineEx(positions[i], positions[j], 1, BLACK);
					break;
				case 2:
					DrawLineEx(positions[i], positions[j], 11,WHITE);
					DrawLineEx(positions[i], positions[j], 1, BLACK);
					Vector2 orthagonal_vector;
					orthagonal_vector.x = -((positions[i].y-positions[j].y)/75*5);
					orthagonal_vector.y = (positions[i].x-positions[j].x)/75*5;
					DrawLineEx(Vector2Add(positions[i],orthagonal_vector), Vector2Add(positions[j],orthagonal_vector), 1, BLACK);
					break;
				case 3:
					DrawLineEx(positions[i], positions[j], 11,WHITE);
					DrawLineEx(positions[i], positions[j], 1, BLACK);
					Vector2 orthagonal_vector2;
					orthagonal_vector2.x = -((positions[i].y-positions[j].y)/75*5);
					orthagonal_vector2.y = (positions[i].x-positions[j].x)/75*5;
					DrawLineEx(Vector2Add(positions[i],orthagonal_vector2), Vector2Add(positions[j],orthagonal_vector2), 1, BLACK);
					DrawLineEx(Vector2Subtract(positions[i],orthagonal_vector2), Vector2Subtract(positions[j],orthagonal_vector2), 1, BLACK);
					break;
				default:
					break;
			}
		}
	}
}

/*
 * add_side_chain()
 * Pushes a new sidechain context onto a stack.
 *
 * We store:
 *  - the atom index where the branch starts (side_chain_head),
 *  - the drawing direction vector before entering the branch (position_increment),
 * so we can restore these when the branch closes.
 */
void add_side_chain(S_list *Sidechains, int current_atom, Vector2 position_increment) {
	S_node *new_side_chain = (S_node *) malloc(sizeof(S_node));
	new_side_chain->next = Sidechains->head;
	new_side_chain->side_chain_head = current_atom;
	new_side_chain->position_increment = position_increment;
	Sidechains->head = new_side_chain;
}


/*
 * remove_side_chain()
 * Pops the top sidechain context from the stack and frees its memory.
 * This is called when encountering a ')' and returning to the main chain.
 */
void remove_side_chain(S_list *Sidechains) {
	S_node *current = Sidechains->head;
	Sidechains->head = current->next;
	free(current);
}
